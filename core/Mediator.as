package core{	import objects.Player;	import objects.Star02;	import flash.display.Stage;	import flash.utils.setTimeout;	import objects.ScoreField;	import objects.StartField;	import objects.TimerField;	import leap.HandState;	import objects.EndField;	public class Mediator {		public static var isCollide:Boolean;		public static var collideStar:Star02;		public static var starArr:Vector.<Star02> = new Vector.<Star02>();		public static var player:Player;		private static var _stage:Stage;		private static var score:ScoreField;		private static var timer:TimerField;		private static var start:StartField;		private static var end:EndField;		private static var mainView:MainView;				private static var sx:Number;		private static var sy:Number;		// 毎フレーム必要な処理はすべてここに記述する		public static function update():void {			// player 座標の更新			player.x = sx;			player.y = sy;			// すべての星座標の更新			for (var i:uint = 0; i < starArr.length; i++) {				var s:Star02 = starArr[i];				if (s.delete_flag) {					starArr.splice(i, 1);					s.parent.removeChild(s);					continue;				}				if (s.move_flag) {					// 加速度を速度に加算					if (s.vx > 0) {						s.vx +=  s.acceleration;					} else {						s.vx -=  s.acceleration;					}					s.vy +=  s.acceleration;					s.x +=  s.vx;					s.y +=  s.vy;				}				// 画面外に出たら消す処理				if (s.x < -10 || s.x > _stage.stageWidth + 10 || s.y < -10 || s.y > _stage.stageHeight + 10) {					starArr.splice(i, 1);					s.parent.removeChild(s);				}				// プレイヤーとの衝突判定(手が開かれている時のみ)				if(player.state === HandState.DEFAULT){					if (Math.abs(s.x - sx) < Mediator.player.width / 2 + s.width / 2) {						if (Math.abs(s.y - sy) < Mediator.player.height / 2 + s.height / 2) {							occurCollision(s);						}					} 				}			}		}		public static function occurCollision(star:Star02):void {			player.collideWith();			isCollide = true;			collideStar = star;			// 衝突後200msは(仮に衝突していなくても)衝突しているとみなす			setTimeout(endCollision, 200);		}				public static function endCollision(catched:Boolean = false):void {			// 衝突後200ms後にまだ衝突範囲内にあり、かつ星が生存していれば再び200msの衝突判定を与える			if ( !collideStar.delete_flag) {				if (Math.abs(collideStar.x - player.x) < Mediator.player.width / 2 + collideStar.width / 2) {					if (Math.abs(collideStar.y - player.y) < Mediator.player.height / 2 + collideStar.height / 2) {						occurCollision(collideStar);						return;					}				}			}						if(player.state === HandState.CATCH){				player.catchState();			}else{				player.defaultState();			}			isCollide = false;		}				public static function changeScore():void {			score.changeScore(collideStar.point);		}				// 外部から手の状態を変更するための関数		public static function changeHandState(handState:int):void {			switch(handState){				case HandState.DEFAULT:					player.defaultState();					break;				case HandState.CATCH:					player.catchState();			}		}				// ゲーム開始時の処理		public static function startGame():void {			mainView = collideStar.parent as MainView;			mainView.terminate = false;			mainView.createStar();			start.visible = false;			end.visible = false;						timer.start(10);		}				// ゲーム終了時の処理		public static function endGame():void {			mainView.terminate = true; // 星を生成しているクラスで終了フラグを立てる						// 画面に残っている星がすべて消えたら終了画面を表示する			setTimeout(wait, 1000);			function wait():void {				if(starArr.length === 0){					end.visible = true;					mainView.createStartStar();					return;				}				setTimeout(wait, 1000);			}					}		public static function registerStage(s:Stage):void {			_stage = s;		}				public static function registerObject(name:String, obj):void {			Mediator[name] = obj;		}		public static function get Sx():Number {			return sx;		}		public static function set Sx(value:Number):void {			sx = value;		}		public static function get Sy():Number {			return sy;		}		public static function set Sy(value:Number):void {			sy = value;		}	}}